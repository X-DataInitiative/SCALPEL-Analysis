# License: BSD 3 clause

import copy
import json
from typing import Dict, Iterable, Set

from scalpel.core.util import fold_right
from scalpel.flattening.flat_table import FlatTable
from scalpel.flattening.single_table import SingleTable


class FlatTableCollection:
    """This object encapsulates a map of flat tables generated from flattening spark jobs.

    Parameters
    ----------
    flat_tables: Dict[str, FlatTable]
        Flat table Dict.
    """

    def __init__(self, flat_tables: Dict[str, FlatTable]):
        assert flat_tables, "Dict can't be empty"
        self._tables = flat_tables

    @staticmethod
    def from_json(json_file: str) -> "FlatTableCollection":
        """
        Build FlatTableCollection from metadata json file.

        Parameters
        ----------
        json_file : str
            Flattening metadata json file, which is generated by flattening.

        Examples
        --------
        >>> with open("metadata_flattening.json", "r") as f:
        ...     collection = FlatTableCollection.from_json(f.read())
        """

        def get_single_tables(tables_json, names):
            return {
                table_json["output_table"]: SingleTable.from_json(table_json)
                for table_json in tables_json
                if table_json["output_table"] in set(names)
            }

        metadata_json = json.loads(json_file)

        return FlatTableCollection(
            {
                table["output_table"]: FlatTable.from_json(
                    table,
                    get_single_tables(metadata_json["operations"], table["sources"]),
                )
                for table in metadata_json["operations"]
                if table["output_type"] == "flat_table"
            }
        )

    @property
    def flat_tables(self) -> Dict[str, FlatTable]:
        return self._tables

    def flat_table_names(self) -> Set[str]:
        """Return flat table names."""
        return set(self._tables.keys())

    def single_table_names_from_flat_table(self, flat_name: str) -> Set[str]:
        """
        Get a set of single tables names from a flat table.

        Parameters
        ----------
        flat_name: str
            Flat table name.
        """
        if self.exists(flat_name):
            return set(self._tables[flat_name].single_tables.keys())
        return set()

    def exists(self, flat_name: str) -> bool:
        """Return if flat table in this collection.

        Parameters
        ----------
        flat_name: str
            Flat table name.
        """
        return flat_name in self._tables

    def get(self, flat_name: str) -> FlatTable:
        """
        Return the flat table by its name.

        Parameters
        ----------
        flat_name: str
            Flat table name.

        Raises
        ------
        KeyError
            Because flat table doesn't exist in this collection.
        """
        if self.exists(flat_name):
            return self._tables[flat_name]
        else:
            raise KeyError(
                "Flat table {} do not exist in current repository".format(flat_name)
            )

    def add_flat_table(self, name: str, flat_table: FlatTable) -> "FlatTableCollection":
        """Return a new collection in adding a flat table in it.

        Parameters
        ----------
        name: str
            Flat table name.
        flat_table: FlatTable
            A flat table.
        """
        new_repo = copy.copy(self)
        new_repo._tables[name] = flat_table
        return new_repo

    def __iter__(self):
        return iter(self._tables)

    def union(self, other: "FlatTableCollection") -> "FlatTableCollection":
        """
        Return a new FlatTableCollection containing union of self and another.

        Parameters
        ----------
        other: FlatTableCollection, a flatTableCollection that will be united.
        """
        return _union(self, other)

    def difference(self, other: "FlatTableCollection") -> "FlatTableCollection":
        """
        Return each flat table in self that is not contained in other.

        Parameters
        ----------
        other: FlatTableCollection, a flatTableCollection that will be compared with self.
        """
        return _difference(self, other)

    def intersection(self, other: "FlatTableCollection") -> "FlatTableCollection":
        """
        Return a new FlatTableCollection containing flat tables both in self and another.

        Parameters
        ----------
        other: FlatTableCollection, a flatTableCollection that will be joined with self.
        """
        return _intersection(self, other)

    @staticmethod
    def union_all(repos: Iterable["FlatTableCollection"]) -> "FlatTableCollection":
        """
        Return a new FlatTableCollection containing union of an iteration of
        FlatTableCollections.

        Parameters
        ----------
        repos: Iterable, an iteration of FlatTableCollections that will be united.
        """
        return fold_right(_union, repos)

    @staticmethod
    def difference_all(repos: Iterable["FlatTableCollection"]) -> "FlatTableCollection":
        """
        Return each flat table in the first that is not contained in others.

        Parameters
        ----------
        repos: Iterable
            An iteration of FlatTableCollections that will be compared with self.
        """
        return fold_right(_difference, repos)

    @staticmethod
    def intersection_all(
        repos: Iterable["FlatTableCollection"],
    ) -> "FlatTableCollection":
        """
        Return a new FlatTableCollection containing flat tables in each from an iteration.

        Parameters
        ----------
        repos: Iterable
            An iteration of FlatTableCollections that will be joined with self.
        """
        return fold_right(_intersection, repos)


def _union(a: FlatTableCollection, b: FlatTableCollection) -> FlatTableCollection:
    new_dict = copy.copy(a.flat_tables)
    new_dict.update(b.flat_tables)
    return FlatTableCollection(new_dict)


def _intersection(
    a: FlatTableCollection, b: FlatTableCollection
) -> FlatTableCollection:
    return FlatTableCollection(
        {key: a.flat_tables[key] for key in set(a).intersection(set(b))}
    )


def _difference(a: FlatTableCollection, b: FlatTableCollection) -> FlatTableCollection:
    return FlatTableCollection({key: a.flat_tables[key] for key in set(a) - set(b)})
